import{_ as s,c as a,o as n,N as o}from"./chunks/framework.8361052b.js";const F=JSON.parse('{"title":"图片等多媒体的处理","description":"","frontmatter":{},"headers":[],"relativePath":"css布局/图片等多媒体的处理.md"}'),l={name:"css布局/图片等多媒体的处理.md"},e=o(`<h1 id="图片等多媒体的处理" tabindex="-1">图片等多媒体的处理 <a class="header-anchor" href="#图片等多媒体的处理" aria-label="Permalink to &quot;图片等多媒体的处理&quot;">​</a></h1><h2 id="替换元素的内在尺寸控制" tabindex="-1">替换元素的内在尺寸控制 <a class="header-anchor" href="#替换元素的内在尺寸控制" aria-label="Permalink to &quot;替换元素的内在尺寸控制&quot;">​</a></h2><blockquote><p>图片或者视频等<strong>替换元素</strong>的内在尺寸只由 width 或者 height 控制，虽然单个属性可以按照原图片的比例缩放，但是<strong>在 css 设置的宽高比</strong>因其<strong>内在尺寸的比例不一致</strong>的情况下被拉伸，这样就会破坏布局。但是我们希望在设置宽度的时候（指定内部尺寸的同时），也希望可以保证内在尺寸的宽高比，这时候就可以使用以下属性。</p></blockquote><ul><li>在图片第一次加载的时候。这时候如果图片还没有加载，浏览器会认为内在尺寸是 0。</li><li>在图片没有加载完毕，占据的高度是0，等图片加载完毕，高度又会再次恢复。</li><li><code>object-fit</code> 和 <code>object-position</code> 都可以让图片的视觉区域在保持比例的情况下适应外部设定的尺寸。</li></ul><h3 id="object-fit" tabindex="-1">object-fit <a class="header-anchor" href="#object-fit" aria-label="Permalink to &quot;object-fit&quot;">​</a></h3><blockquote><p>object-fit 属性只支持关键字属性</p></blockquote><ul><li><code>object-fit: fill | contain | cover | none | scale-down</code></li></ul><ol><li><code>fill</code>:默认值。表示<strong>填充</strong>，替换元素会拉伸，填满整个 content-box 的尺寸，不保证保持原有的比例。</li><li><code>contain</code>:<strong>包含</strong>。替换内容保持原有尺寸比例，同时替换内容一定可以在 <code>content-box</code> 中完整显示，至少一个方向的尺寸和 <code>content-box</code> 保持一致 <ul><li>此关键字可能会让 content-box 出现留白</li></ul></li><li><code>cover</code>:<strong>覆盖</strong>。替换内容同样会保持原有的尺寸比例，同时替换内容会完全覆盖 <code>content-box</code> 区域，至少一个方向的尺寸和 <code>content-box</code> 保持一致 <ul><li>此关键字可能会让替换内容的部分区域不可见</li></ul></li><li><code>none</code>:替换内容的尺寸显示为原始的尺寸，无视外部的尺寸设置。如果尺寸减小，就会有大量留白;如果图片尺寸较大，则会有较大面积的图片区域被裁剪</li><li><code>scale-down</code>:样式表现就好像依次设置 <code>none</code> 和 <code>contain</code> 关键字，然后选取呈现较小的那个效果</li></ol><blockquote><p>通常缩略图使用 cover 关键字，列表图使用 contain 关键字，全屏大图预览使用 scale-down 关键字</p></blockquote><h3 id="object-position" tabindex="-1">object-position <a class="header-anchor" href="#object-position" aria-label="Permalink to &quot;object-position&quot;">​</a></h3><blockquote><p>object-position 控制替换内容的位置。<code>object-position</code> 的初始值是 <strong>50% 50%</strong>，默认居中</p></blockquote><ul><li><p>与<code>background-position</code>相似，object-position 的值类似为&lt;position&gt;</p><div class="language-css"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#676E95;font-style:italic;">/*定位在content-box右下角*/</span></span>
<span class="line"><span style="color:#FFCB6B;">object-position</span><span style="color:#A6ACCD;">:100% 100%;</span></span>
<span class="line"></span></code></pre></div></li><li><p>css中设置<code>background-image</code>图像实现懒加载成本较高。在css中如果设置的是&lt;img&gt;内联图像，那么只需要一个loading属性</p><div class="language-html"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">&lt;</span><span style="color:#F07178;">img</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">src</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;&quot;</span><span style="color:#89DDFF;"> </span><span style="color:#C792EA;">loading</span><span style="color:#89DDFF;">=</span><span style="color:#89DDFF;">&quot;</span><span style="color:#C3E88D;">lazy</span><span style="color:#89DDFF;">&quot;</span><span style="color:#89DDFF;">&gt;</span></span>
<span class="line"></span></code></pre></div></li></ul><h3 id="image-rendering" tabindex="-1">image-rendering <a class="header-anchor" href="#image-rendering" aria-label="Permalink to &quot;image-rendering&quot;">​</a></h3><blockquote><p>image-rendering属性是用来设置图像的缩放算法，主要针对PNG和JPG这类位图</p></blockquote><ul><li><p><code>image-rendering</code>属性可以设置在&lt;img&gt;元素上，也可以设置在&lt;img&gt;元素的父元素上</p></li><li><p>并且image-rendering属性在不同的浏览器中的应用属性均不相同</p></li><li><p>语法<code>image-rendering: auto | crisp-edges | pixelated</code></p></li></ul><ol><li><code>auto</code>:表示浏览器自动选择使用何种图像缩放算法。通常是平滑缩放</li><li><code>crisp-edges</code>:不使用平滑缩放。缩放的图像会有较高的对比度和锐利的边缘，也不会有模糊的感觉</li><li><code>pixelated</code>:表示当放大图像时，必须使用邻近的算法，使用图像看起来又大像素块组成;缩小图像时，使用与auto关键字属性值相同的算法</li></ol><div class="language-css"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">auto</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">image-rendering</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> auto</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/* 图像边缘锐化 */</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">crisp-edges</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">image-rendering</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> -webkit-optimize-contrast</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#B2CCD6;">image-rendering</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> crisp-edges</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#676E95;font-style:italic;">/* 图像像素化 */</span></span>
<span class="line"><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">pixelated</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#FFCB6B;">-ms-interpolation-mode</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> nearest-neighbor</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span><span style="color:#B2CCD6;">image-rendering</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> pixelated</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><blockquote><p>在通常情况下，使用平滑的效果肯定是好的，用不到 image-rendering。如果网页的设计风格是像素化风格，就可以使用image-rendering属性改变图像的缩放</p></blockquote><h3 id="图像类型函数-不常用" tabindex="-1">图像类型函数(不常用) <a class="header-anchor" href="#图像类型函数-不常用" aria-label="Permalink to &quot;图像类型函数(不常用)&quot;">​</a></h3><blockquote><p>常用的图像类型函数<code>url()</code>，<code>*-gradient()</code>渐变函数和<code>image-set()</code>图像设置函数</p></blockquote><h4 id="cross-fade" tabindex="-1">cross-fade() <a class="header-anchor" href="#cross-fade" aria-label="Permalink to &quot;cross-fade()&quot;">​</a></h4><blockquote><p>cross-fade()函数可以让两种图像半透明混合</p></blockquote><div class="language-css"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">div</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">height</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">200px</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">width</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">200px</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">background-image</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> -webkit-cross-fade(</span><span style="color:#82AAFF;">url</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">./banner/0.jpg</span><span style="color:#89DDFF;">),</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">url</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">./banner/1.jpg</span><span style="color:#89DDFF;">),</span><span style="color:#A6ACCD;"> </span><span style="color:#F78C6C;">30%</span><span style="color:#A6ACCD;">)</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">background-size</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> cover</span><span style="color:#89DDFF;">;</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div><ul><li>本例使用传统语法:<code>cross-fade(&lt;image&gt;,&lt;iamge&gt;,&lt;percentage&gt;)</code><ul><li><code>percentage</code>值会改变第二张图像的透明度，最终只会是第一张完全不透明和第二张的透明叠加</li><li>只有使用 url() 才可以有效</li></ul></li><li><code>cross-fade()</code>函数处理后图像尺寸是受到透明度影响的 <ol><li>如果透明度是0，则处理后的图像是 0.jpg</li><li>如果透明度是100%，则处理后的图像是 1.jpg</li><li>如果透明度是0~100%，则处理后的图像的尺寸在0~1之间变化的</li></ol></li></ul><blockquote><p>cross-fade()函数的新语法可以指定任意数量的透明叠加图像，同时可以分别指定每张图像的透明度(没有浏览器支持)</p></blockquote><div class="language-css"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">cross-fade(url(green</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">png</span><span style="color:#A6ACCD;">) 75%, url(red</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">png</span><span style="color:#A6ACCD;">) 75%); </span></span>
<span class="line"><span style="color:#A6ACCD;">cross-fade(url(red</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">png</span><span style="color:#A6ACCD;">) 20%, url(yellow</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">png</span><span style="color:#A6ACCD;">) 30%, url(blue</span><span style="color:#89DDFF;">.</span><span style="color:#FFCB6B;">png</span><span style="color:#A6ACCD;">) 50%);</span></span>
<span class="line"></span></code></pre></div><h4 id="element" tabindex="-1">element() <a class="header-anchor" href="#element" aria-label="Permalink to &quot;element()&quot;">​</a></h4><blockquote><p>element()函数会让页面中任意的DOM元素的渲染效果变成图像(仅有firefox支持)</p></blockquote><ul><li>语法:<code>element(#id)</code></li></ul><div class="language-css"><button title="Copy Code" class="copy"></button><span class="lang">css</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#FFCB6B;">div</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">background</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> -moz-element(#button)</span><span style="color:#89DDFF;">;</span><span style="color:#A6ACCD;"> </span></span>
<span class="line"><span style="color:#A6ACCD;">  </span><span style="color:#B2CCD6;">background</span><span style="color:#89DDFF;">:</span><span style="color:#A6ACCD;"> </span><span style="color:#82AAFF;">element</span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">#button</span><span style="color:#89DDFF;">);</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre></div>`,30),p=[e];function t(c,r,i,d,D,y){return n(),a("div",null,p)}const g=s(l,[["render",t]]);export{F as __pageData,g as default};
