# css

## css选择器

> css选择器分为四类,选择器,选择符,伪类和伪元素

1. 选择器:即平常使用的css声明块之前的标签,类名
2. 选择符:例如`( )`,`*`等等
3. 伪类:前面会有一个冒号`:`
4. 伪元素:前面会有两个`::`

> 选择器作用域`:scope`,不会在整个文档中寻找,而是当下元素的作用域中寻找符合元素

### 命名

1. 命名建议使用小写,使用英文单词或者缩写(不建议使用驼峰,那是js的规范)
2. 对于组合命名可以使用`-`或者`_`连接
3. 设置统一前缀,避免样式名冲突

```css
.login-header{}
.login-logo{}
.login-logo-a{}
```

### 优先级

* 选择器相同 执行层叠性
* 选择器不同,则根据<span style="color:red">选择器权重</span>执行

| 选择器              | 选择器权重 |
| ------------------- | ---------- |
| 继承或者*           | 0,0,0,0    |
| 元素选择器          | 0,0,0,1    |
| 类选择器,伪类选择器 | 0,0,1,0    |
| ID选择器            | 0,1,0,0    |
| 行内样式style=""    | 1,0,0,0    |
| !important重要的    | 无穷大     |

* 注意:
   1. 权重是有4组数字,不会有进位
   2. 从左向右判断,如果某一位数值相同,则判断下一位数值
   3. <span style="color:red">继承的权重是0,(重要)</span>,如果该元素没有直接选中,不管父元素权重多高,子元素得到的权重都是0

* 权重叠加:如果是复合选择器,则会有权重叠加,需要计算权重

### 选择符

> 后代选择器`( )`:元素1元素2{样式},例```ul li {color:red;}```

* 注意:元素2必须是子级,只要是元素的子级都可以选到
* 元素1和2可以是任意基础选择器

> 子选择器`>`(重要):`元素1>元素2`(样式声明),表示选择元素1里的所有直接后代的(子元素)元素2,例:`div > a{color:red;}`

* 元素1是父级,元素2是子级,最终选择的元素是元素2
* 元素2必须是最近一级的子级(亲儿子),子子集(孙子)等都不归他管

   ```html
   <style>
     div > a{color:red;}
   </style>
   ...
   <div>
     <a href="#">你好</a>
     <p>
       <a href="#">你好(选不到)</a>
     </p>
   </div>
   ```

* <span style="color:red">注意:尽量避免使用子选择符,一旦使用了子选择符,元素的层级关系就被定死了</span>

>相邻兄弟选择符(`+`):用于选择相邻的兄弟元素,但是只能选择后面的一个元素

* 元素会主动忽略文本节点和注释节点

>随后兄弟选择符`(~)`:随后兄弟选择符会匹配后面的所有元素,而相邻兄弟选择符,只会匹配后面的第一个元素

* 由于DOM层级是从前往后,由外及里渲染的,所以没有前面的兄弟选择符

> 列选择符双道(||):可以理解为属于的意思

* 在Table或者Grid布局中,希望控制整列的方式

```css
col .selected || td{}
```

### 选择器

#### 提高优先级

> 类选择器,id选择器,和属性值匹配选择器可以重复自身

```css
.foo.foo{}
#foo#foo{}
[foo][foo]{}
```

>借助html页面中都有的\<body>\<html>提高优先级

```css
html .foo{}
```

> 借助`:not()`伪类,表示任意和括号里不一样的标签名即可

```css
foo:not(foo){}
```

#### 元素选择器

1. 标签选择器: `h2{}`
   * 标签选择器,只能写在属性值选择器前面,但是类选择器完全可以写在属性值选择器之后
   * 因为css选择器的解析是从右往左进行的

   ```css
   /* 正确 */
   input[value="hello"]{}
   /* 错误 */
   [value="hello"]input{}
   ```

2. 类选择器:样式点定义 结构类(class)调用 一个或多个
   * <span style="color:red">注意:可以写多个类名,但是中间必须使用空格</span>
3. id选择器:样式#定义,结构id调用,只能调用一次,其它切勿调用

    ```html
    <style>
      #red{
        color:red;
      }
    </style>
    
    ...
    <h2 id="red">你好</h2>
    ```

4. 通配符选择器:```*{}```所有标签的属性都会增加

#### 属性选择器

>\[attr]:表示只要含有指定的属性就会匹配,尤其是使用一些html布尔属性,这些布尔属性值的内容是什么,都认为这些属性值是true

* 同时attr属性不仅支持原生,同时也可以自定义

   | 选择符        | 简介                                  |
   | ------------- | ------------------------------------- |
   | E[att]        | 选择具有att属性的E元素                |
   | E[att="val"]  | 选择具有att属性且属性值等于val的E元素 |
   | E[att         | ="val"]                               | 选择具有att属性且属性值是val或者使用`-`连接 |
   | E[att~="val"] | 选择具有att属性且属性值包含val的E元素 |
   | E[att^="val"] | 匹配具有att属性且值以val开头的E元素   |
   | E[att$="val"] | 匹配具有att属性且值以val结尾的E元素   |
   | E[att*="val"] | 匹配具有att属性且值中含有的E元素      |

>`E[att~="val"]`:匹配属性中的单词,其中~用来连接属性和属性值

* 像class属性或者rel等属性包含多个关键词,就可以使用

```css
[attr~="val"]{}
```

```html
<!-- 不匹配 -->
<div attr="value"></div>
<!-- 不匹配 -->
<div attr="val-ue"></div>
<!-- 匹配 -->
<div attr=" val "></div>
<!-- 匹配 -->
<div attr=" val   ue"></div>
```

* 如果字符串前后有空格或者连续多个,才可以匹配

>E\[att|="val"] 选择具有att属性且属性值是val或者val开头并且使用`-`连接

```css
[attr|="val"]{}
```

```html
<!-- 不匹配 -->
<div attr="value"></div>
<!-- 匹配 -->
<div attr="val-ue"></div>
<!-- 匹配 -->
<div attr="val"></div>
<!-- 不匹配 -->
<div attr="val bar"></div>
<!-- 不匹配 -->
<div attr="bar val-ue"></div>
```

#### 忽略属性值大小写的正则匹配运算符

>其中`i`字符是正则匹配运算符,可以忽略属性值的大小写

```css
[attr~="val" i]{}
```

### 伪类

#### 用户伪类选择器

* `a:link`   /*选择所有未被访问的链接*/  
* `a:visited`   /*选择所有已被访问的链接*/  
* `a:hover`   /*选择所有指针位于其上的链接*/  
* `a:active`   /*选择所有活动的链接(鼠标按下未弹起)*/
* 注意:  
  * <span style="color:red">请按照LVHA的顺序声明:link-:visited-:hover-:active</span>
  * 因为链接在浏览器中有单独默认样式,所以在实际工作中需要给链接指定单独样式
  
> `:focus`伪类选择器,用于获得焦点.默认纸皮撇特定元素

1. 非disabled状态的元素,如\<input>输入框,\<select>,\<button>等
2. 包含href的\<a>
3. html5中的\<summary>

* <span style="color:red">如果设置了`contenteditable`</span>属性的普通元素也可以使用`:focus`

```html
<div contenteditable="true"></div>
```

>`:focus-within`会在当前元素或者当前元素的任意子元素处于聚焦状态就会触发

* 然而`:focus`只有在当前元素处于聚焦状态的时候才匹配

> `:focus-visible`:元素聚焦,同时浏览器认为聚焦轮廓应该显示

* 当我们使用键盘或者鼠标访问链接元素\<a>是,鼠标点击不会有轮廓,而键盘会有
* 浏览器认为使用键盘访问触发元素聚焦才是`:focus-visible`所表现的聚焦
  * 可以让我们知到元素的聚焦行为到底是鼠标触发还是浏览器触发

* 去除鼠标点击的outline,保留键盘触发的outline

```css
:focus:not(:focus-visible){outline:0;}
```

#### url伪类

>链接地址访问有关的两个伪类

* `a:link`   /*选择所有未被访问的链接*/  
* `a:visited`   /*选择所有已被访问的链接*/  

>`:target`,标记锚点锚定的元素(只有在url产生锚点的一瞬间会触发伪类的匹配)
>
>`:target-within`:会在当前元素或者当前元素的任意子元素处于聚焦状态就会触发

#### 控件伪类

> `:disabled`当元素处于禁用状态时触发

```html
<input disabled>
<style>
  [disabled]:disabled{
    background:red;
  }
</style>
```

* 关于`:enabled`伪类.由于表单元素迷人就是`enabled`状态的,不需要额外匹配`:enabled`

> 读写特性伪类`:read-only`和`:read-write`

* 这两个伪类中作用于\<input>和\<textarea>
* 由于输入框的默认状态就是`:read-write`,基本不会使用

>`:placeholder-shown`,占位显示伪类

* `:placeholder-shown`与`placeholder`属性密切相关,当输入框`placeholder`内容显示的时候,匹配该输入框

>`:default`默认选项伪类

* 只作用于表单元素,表示处于默认状态的表单元素

>`:checked`:选中选项伪类

* 不要直接使用`[checked]`
  * `:checked`只能匹配标准的表单元素,不能匹配其它的元素,即使这个元素设置`checked`属性.不过\[checked]属性选择器可与任意元素匹配
  * \[checked]属性的变化也不是实时的

>`:indeterminate`不确定值伪类

* 在复选框中除了选中和没选中状态还有半选状态.由于没有原生的html属性,只能使用js属性设置`checkbox.indeterminate=true`
* 这个伪类可以用来提示用户尚未选择任何选项,如果有选项选项,则自动消失

> `:required和:optional`可选性伪类

* `:required`伪类用于匹配设置required属性的表单元素,表示这谷歌元素必填(只会匹配设置了required属性的元素)
* `:optional`伪类可以当作`:required`的对立面,只要表单元素没有设置`required`属性,都可以匹配:optional属性

### 树结构伪类

>`:root`表示文档根元素伪类

* `:root`与\<html>的区别:首先`:root`伪类的优先级更高,伪类的优先级比标签选择器高一个等级
* 一般用于存放css自定义变量

>`:empty`伪类

1. `:empty`伪类用于匹配空元素标签
2. 同时也可以匹配前后闭合的替换元素,如\<button>和\<textarea>
3. 还可以匹配非闭合元素,如\<img>,\<input>,\<hr>等

* 如果在元素内有文本节点或者注释节点,包括空格换行,都不可以匹配
* `::before`和`::after`伪元素可以给标签插入内容,图形,但是不会影响`:empty`伪类的匹配

* 如果某个模块是动态的,这些模块容器包含影响布局的css属性,如margin等.一旦这些模块里的东西变为空页面上就有一块很大的空白
* 这种情况就可以使用`:empty`伪类控制

```css
cs-module:empty{
  display:none;
}
```

#### 子索引伪类
  
> `E:first-child`:匹配E元素中的第一个元素(或者说当前作用域的第一个)

* `E:last-child`:匹配E元素中的最后一个元素

```html
<style>
  li:first-child{
    color:red;
  }
</style>
...
<ul>
  <li>hhhh</li>
  <li>hhhh</li>
  <li>hhhh</li>
  <li>hhhh</li>
</ul>
```

>`:only-child`:匹配没有任何兄弟元素的元素

* 可以用到很多动态的场景,例如某个加载(loading)模块里有一段加载文字,或者只有一张加载图片,或者两者需要同时出现,此时使用就可以使用`:only-child`

>`E:nth-child(n)`:匹配E元素中的第n个元素
>
> `E:nth-last-child(n)`:从后往前匹配,匹配E元素中的第n个元素

* nth-child(n) 选择某个父元素的一个或多个特定的子元素
  * n可以是数字,关键字和公式
  * n如果是数字,就是第n个子元素,里面数字从1开始
  * n可以是关键字:even是偶数,odd是奇数
  * n可以是公式:常见的公式如下(如果n是公式,则从0开始计算,但是第0个元素或者超出的元素会被忽略)

| 公式 | 取值                           |
| ---- | ------------------------------ |
| 2n   | 偶数                           |
| 2n+1 | 奇数                           |
| 5n   | 5  10 ....                     |
| n+5  | 从第五个开始(包含第五个)到最好 |
| -n+5 | 前五个(包含第五个)             |

* 注意:```nth-child(n)```给所有元素都排列序号,要求选择器与标签匹配得当
* 注意:```nth-of-type(n)```给指定元素都排列序号
* 注意:使用与动态,无法确定的匹配场景,如果是纯静态的,不管是列表,都最好用属性选择器或者类名

#### 匹配类型的子索引伪类

> 匹配类型的子索引伪类会在同级目录中相同标签元素进行索引域解析(需要使用语义化标签)

* `:first-of-type`:指定同级类型各个元素怒的第一个或者当前标签的元素
* `:last-of-type`:指定同级类型各个元素怒的最后一个或者当前标签的元素

```html
<style>
  ul>:first-of-type {
    color: red;
  }
</style>
<ul>
  <li>chifan</li>
  <li>hhhh</li>
  <dt>aaa</dt>
  <dt>aaa</dt>
</ul>
```

>`:only-of-type`:匹配同级唯一的标签类型元素,或者当前标签的元素

* `:nth-of-type(n)`匹配同级类型各个元素或者当前标签的元素
* `:nth-last-of-type(n)`从后往前匹配,匹配同级类型各个元素或者当前标签的元素

### 逻辑组合伪类

>`:not()`否定伪类,如果当前元素域括号里的选择器不匹配,则该伪类进行匹配

1. :not()伪类的优先级是0,本省没有任何优先级,最终选择器的优先级由括号里的表达式决定
2. :not()可以不断联级
   * `input:not(:disabled):not(:read-only){}`
   * 匹配所有不处于禁用状态,也不处于只读状态的\<input>
3. :not()伪类目前已支持多个表达式

   ```html
   <style>
     button:not(.a, .b) {
       background-color: green;
     }
   </style>
   <button>没有class</button>
   <button class="a">class="a"</button>
   <button class="b">class="a b"</button>
   <button class="a b">class="a b"</button>
   ```

4. :not()可以优化重置css样式的策略
   * 并且他的代码更简洁,更易维护和理解

> `:is()`:伪类可以把括号里的选择器依次分配出取,对于那种复杂的有很多都好分割的选择器非常有用

```css
/* 不使用is */
.cs-avatar1>img,
.cs-avatar2>img,
.cs-avatar3>img{}

/* 使用is */
:is(.cs-avatar,.cs-avata2,.cs-avata3)>img{}
```

> :where()任意匹配伪类

* 他与`:is()`伪类的含义语法完全一样,唯一的区别就是`:where()`的优先级永远是0

### 其它伪类

>方向伪类`:dir(ltr|rtl)`,可以直接使用html中的dir属性

* 像聊天记录的对话框
* 有时候我们希望布局元素是从右往左排列的.由于使用`[dir="rtl"]`会使子元素继承这样的文档流形式
* 所以使用`:dir()`伪类可以更精确的匹配
